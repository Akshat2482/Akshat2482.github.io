<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>AR Vision Pro Keyboard</title>
  <style>
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
    #info {
      position: absolute; left: 0; right: 0; top: 0;
      color: #9cf; font: 14px/1.4 system-ui, sans-serif;
      background: rgba(0,0,0,0.7); padding: 8px 12px; z-index: 3;
    }
    #hud {
      position: absolute; inset: 0; pointer-events: none; z-index: 2;
    }
    .reticle {
      position: absolute; left: 50%; top: 50%; width: 60px; height: 60px;
      border: 2px solid rgba(140,220,255,0.8); border-radius: 50%;
      transform: translate(-50%,-50%);
      box-shadow: 0 0 12px rgba(140,220,255,0.6);
    }
    .tick { position: absolute; width: 2px; height: 18px; background: rgba(140,220,255,0.8); }
    .tick.t1 { left: 50%; top: calc(50% - 50px); transform: translateX(-50%); }
    .tick.t2 { left: 50%; top: calc(50% + 32px); transform: translateX(-50%); }
    .tick.t3 { top: 50%; left: calc(50% - 50px); transform: translateY(-50%); }
    .tick.t4 { top: 50%; left: calc(50% + 48px); transform: translateY(-50%); }
    
    /* Make AR button visible and styled */
    #ARButton {
      position: fixed !important;
      bottom: 20px !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      padding: 15px 40px !important;
      background: #1E88E5 !important;
      color: white !important;
      border: none !important;
      border-radius: 8px !important;
      font-size: 18px !important;
      font-weight: bold !important;
      cursor: pointer !important;
      z-index: 999 !important;
      box-shadow: 0 4px 12px rgba(30, 136, 229, 0.4) !important;
    }
    
    #ARButton:hover {
      background: #1976D2 !important;
    }
  </style>
</head>
<body>
  <div id="info">‚å®Ô∏è TAP ANYWHERE = Spawn keyboard | Look at key + tap = Type | Grab keyboard = Look at base + tap</div>
  <div id="hud">
    <div class="reticle"></div>
    <div class="tick t1"></div><div class="tick t2"></div><div class="tick t3"></div><div class="tick t4"></div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { ARButton } from "https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js";

    let camera, scene, renderer;
    let reticle, controller;
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    const panels = [];
    const raycaster = new THREE.Raycaster();
    let activePanel = null;
    let currentText = "";
    let textDisplayPanel = null;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.01, 20);

      renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true,
        powerPreference: "high-performance"
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.outputEncoding = THREE.sRGBEncoding;
      
      document.body.appendChild(renderer.domElement);

      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      scene.add(light);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const geometry = new THREE.RingGeometry(0.06, 0.075, 32).rotateX(-Math.PI / 2);
      const material = new THREE.MeshBasicMaterial({ color: 0x8cdcff });
      reticle = new THREE.Mesh(geometry, material);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      controller = renderer.xr.getController(0);
      controller.addEventListener("select", onSelect);
      scene.add(controller);

      renderer.domElement.addEventListener("click", onCanvasClick);

      const arButton = ARButton.createButton(renderer, {
        requiredFeatures: ["hit-test"],
        optionalFeatures: ["dom-overlay"],
        domOverlay: { root: document.body }
      });
      arButton.id = 'ARButton';  // Set ID for CSS styling
      document.body.appendChild(arButton);

      window.addEventListener("resize", onWindowResize);
    }

    function onSelect() { handleClick(); }
    function onCanvasClick() { handleClick(); }

    function handleClick() {
      const hitKey = getKeyUnderGaze();
      if (hitKey) {
        handleKeyPress(hitKey.userData.key);
        return;
      }

      const hitPanel = getPanelUnderGaze();
      if (activePanel) {
        activePanel.userData.selected = false;
        activePanel.scale.setScalar(1);
        activePanel = null;
        return;
      }

      if (hitPanel && !hitPanel.userData.isKey) {
        activePanel = hitPanel;
        activePanel.userData.selected = true;
        activePanel.scale.setScalar(1.05);
        return;
      }

      if (reticle.visible) {
        spawnKeyboard();
      }
    }

    function handleKeyPress(key) {
      console.log('Key:', key);
      
      if (key === 'space') {
        currentText += ' ';
      } else if (key === 'backspace') {
        currentText = currentText.slice(0, -1);
      } else if (key === 'return') {
        currentText += '\n';
      } else if (key === 'shift') {
        // Toggle case (simplified)
      } else if (key === '123') {
        // Switch to numbers (simplified)
      } else if (key === 'emoji') {
        currentText += 'üòä';
      } else {
        currentText += key;
      }

      updateTextDisplay();
    }

    function updateTextDisplay() {
      if (textDisplayPanel && textDisplayPanel.userData.textCtx) {
        const ctx = textDisplayPanel.userData.textCtx;
        const tex = textDisplayPanel.userData.textTexture;

        ctx.clearRect(0, 0, 1024, 200);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '28px system-ui';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        
        const maxWidth = 980;
        const lineHeight = 35;
        let y = 20;
        
        const lines = currentText.split('\n');
        lines.forEach(line => {
          ctx.fillText(line || '', 20, y);
          y += lineHeight;
        });

        // Cursor
        if (Date.now() % 1000 < 500) {
          const lastLine = lines[lines.length - 1] || '';
          const cursorX = ctx.measureText(lastLine).width + 20;
          ctx.fillRect(cursorX, y - lineHeight, 2, 25);
        }

        tex.needsUpdate = true;
      }
    }

    function getKeyUnderGaze() {
      const origin = new THREE.Vector3();
      const direction = new THREE.Vector3();
      camera.getWorldPosition(origin);
      camera.getWorldDirection(direction);
      raycaster.set(origin, direction);

      const allKeys = [];
      panels.forEach(panel => {
        panel.traverse(child => {
          if (child.userData && child.userData.isKey) {
            allKeys.push(child);
          }
        });
      });

      const hits = raycaster.intersectObjects(allKeys, false);
      return hits.length > 0 ? hits[0].object : null;
    }

    function getPanelUnderGaze() {
      const origin = new THREE.Vector3();
      const direction = new THREE.Vector3();
      camera.getWorldPosition(origin);
      camera.getWorldDirection(direction);
      raycaster.set(origin, direction);

      const hits = raycaster.intersectObjects(panels, true);
      if (!hits.length) return null;

      let candidate = hits[0].object;
      while (candidate && !candidate.userData.isPanel) {
        candidate = candidate.parent;
      }
      return candidate;
    }

    function spawnKeyboard() {
      const keyboard = makeVisionProKeyboard();
      keyboard.position.setFromMatrixPosition(reticle.matrix);
      keyboard.quaternion.setFromRotationMatrix(reticle.matrix);
      scene.add(keyboard);
      panels.push(keyboard);

      // Text panel above
      const textPanel = makeTextPanel();
      textPanel.position.setFromMatrixPosition(reticle.matrix);
      textPanel.quaternion.setFromRotationMatrix(reticle.matrix);
      textPanel.position.y += 0.35;
      scene.add(textPanel);
      panels.push(textPanel);
      textDisplayPanel = textPanel;
    }

    function makeTextPanel() {
      const group = new THREE.Group();

      // Simple rounded background
      const bgGeom = new THREE.PlaneGeometry(1.4, 0.25);
      const bgMat = new THREE.MeshPhysicalMaterial({
        color: 0x3a3a4a,
        transparent: true,
        opacity: 0.95,
        roughness: 0.3,
        metalness: 0.1
      });
      const bg = new THREE.Mesh(bgGeom, bgMat);
      group.add(bg);

      // Border for rounded effect
      const borderGeom = new THREE.EdgesGeometry(bgGeom);
      const borderMat = new THREE.LineBasicMaterial({ color: 0x5a5a6a, opacity: 0.5, transparent: true });
      const border = new THREE.LineSegments(borderGeom, borderMat);
      group.add(border);

      // Title "Text preview"
      const titleCanvas = document.createElement('canvas');
      titleCanvas.width = 512;
      titleCanvas.height = 64;
      const titleCtx = titleCanvas.getContext('2d');
      titleCtx.fillStyle = 'rgba(180, 180, 190, 0.9)';
      titleCtx.font = '24px system-ui';
      titleCtx.textAlign = 'center';
      titleCtx.fillText('Text preview', 256, 35);
      
      const titleTex = new THREE.CanvasTexture(titleCanvas);
      const titleMat = new THREE.MeshBasicMaterial({ map: titleTex, transparent: true });
      const titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.05), titleMat);
      titleMesh.position.set(0, 0.08, 0.01);
      group.add(titleMesh);

      // Text display
      const textCanvas = document.createElement('canvas');
      textCanvas.width = 1024;
      textCanvas.height = 200;
      const textCtx = textCanvas.getContext('2d');
      const textTexture = new THREE.CanvasTexture(textCanvas);
      textTexture.minFilter = THREE.LinearFilter;

      const textMat = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true });
      const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.3, 0.15), textMat);
      textMesh.position.set(0, -0.02, 0.01);
      group.add(textMesh);

      group.userData.isPanel = true;
      group.userData.textCtx = textCtx;
      group.userData.textTexture = textTexture;

      return group;
    }

    function makeVisionProKeyboard() {
      const group = new THREE.Group();

      // Main keyboard background - simple plane
      const kbGeom = new THREE.PlaneGeometry(1.5, 0.65);
      const kbMat = new THREE.MeshPhysicalMaterial({
        color: 0x4a4a5a,
        transparent: true,
        opacity: 0.95,
        roughness: 0.4,
        metalness: 0.1
      });
      const kbBg = new THREE.Mesh(kbGeom, kbMat);
      group.add(kbBg);

      // Border
      const borderGeom = new THREE.EdgesGeometry(kbGeom);
      const borderMat = new THREE.LineBasicMaterial({ color: 0x6a6a7a, opacity: 0.6, transparent: true });
      const border = new THREE.LineSegments(borderGeom, borderMat);
      group.add(border);

      // Suggestion bar
      makeSuggestionBar(group);

      // Keyboard rows
      const rows = [
        ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
        ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'],
        ['shift', 'z', 'x', 'c', 'v', 'b', 'n', 'm', 'backspace'],
        ['123', 'emoji', 'space', 'return']
      ];

      const keySize = 0.09;
      const spacing = 0.01;
      const startY = 0.18;

      rows.forEach((row, rowIdx) => {
        let xOffset = 0;
        
        // Center each row
        const rowWidth = row.reduce((sum, key) => {
          let w = keySize;
          if (key === 'space') w = keySize * 4.5;
          if (key === 'shift' || key === 'backspace') w = keySize * 1.3;
          if (key === '123' || key === 'return') w = keySize * 1.5;
          if (key === 'emoji') w = keySize * 1.2;
          return sum + w + spacing;
        }, 0) - spacing;
        
        xOffset = -rowWidth / 2;

        row.forEach(char => {
          let width = keySize;
          if (char === 'space') width = keySize * 4.5;
          if (char === 'shift' || char === 'backspace') width = keySize * 1.3;
          if (char === '123' || char === 'return') width = keySize * 1.5;
          if (char === 'emoji') width = keySize * 1.2;

          const key = makeRoundKey(char, width, keySize);
          key.position.x = xOffset + width / 2;
          key.position.y = startY - rowIdx * (keySize + spacing);
          key.position.z = 0.02;
          group.add(key);

          xOffset += width + spacing;
        });
      });

      group.userData.isPanel = true;
      group.userData.isKeyboard = true;

      return group;
    }

    function makeSuggestionBar(group) {
      const suggestions = ['I', 'The', "I'm"];
      const suggWidth = 0.3;
      const spacing = 0.03;
      const startX = -0.4;
      const y = 0.25;

      suggestions.forEach((text, idx) => {
        const suggBox = new THREE.PlaneGeometry(suggWidth, 0.08);
        const suggMat = new THREE.MeshPhysicalMaterial({
          color: 0x5a5a6a,
          transparent: true,
          opacity: 0.9,
          roughness: 0.3
        });
        const suggMesh = new THREE.Mesh(suggBox, suggMat);
        suggMesh.position.set(startX + idx * (suggWidth + spacing), y, 0.02);
        group.add(suggMesh);

        // Text
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 48px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(text, 128, 70);

        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(0.25, 0.06), mat);
        mesh.position.set(startX + idx * (suggWidth + spacing), y, 0.03);
        group.add(mesh);
      });

      // Microphone icon (right side)
      const micBox = new THREE.PlaneGeometry(0.09, 0.08);
      const micMat = new THREE.MeshPhysicalMaterial({
        color: 0x5a5a6a,
        transparent: true,
        opacity: 0.9
      });
      const micMesh = new THREE.Mesh(micBox, micMat);
      micMesh.position.set(0.6, y, 0.02);
      group.add(micMesh);

      // Mic icon
      const micCanvas = document.createElement('canvas');
      micCanvas.width = 128;
      micCanvas.height = 128;
      const micCtx = micCanvas.getContext('2d');
      micCtx.fillStyle = '#ffffff';
      micCtx.font = '48px system-ui';
      micCtx.textAlign = 'center';
      micCtx.fillText('üé§', 64, 75);

      const micTex = new THREE.CanvasTexture(micCanvas);
      const micIconMat = new THREE.MeshBasicMaterial({ map: micTex, transparent: true });
      const micIcon = new THREE.Mesh(new THREE.PlaneGeometry(0.07, 0.06), micIconMat);
      micIcon.position.set(0.6, y, 0.03);
      group.add(micIcon);
    }

    function makeRoundKey(char, width, height) {
      const group = new THREE.Group();

      // Use circle for round keys (Vision Pro style)
      const radius = Math.min(width, height) / 2;
      const keyGeom = new THREE.CircleGeometry(radius, 32);
      const keyMat = new THREE.MeshPhysicalMaterial({
        color: 0x6a6a7a,
        transparent: true,
        opacity: 0.95,
        roughness: 0.3,
        metalness: 0.2,
        clearcoat: 0.3
      });
      const keyMesh = new THREE.Mesh(keyGeom, keyMat);
      group.add(keyMesh);

      // Subtle border
      const borderGeom = new THREE.RingGeometry(radius * 0.95, radius, 32);
      const borderMat = new THREE.MeshBasicMaterial({ 
        color: 0x8a8a9a, 
        transparent: true, 
        opacity: 0.3 
      });
      const border = new THREE.Mesh(borderGeom, borderMat);
      border.position.z = 0.001;
      group.add(border);

      // Label
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 48px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      let displayText = char;
      if (char === 'space') displayText = 'space';
      if (char === 'backspace') displayText = '‚å´';
      if (char === 'return') displayText = 'return';
      if (char === 'shift') displayText = '‚áß';
      if (char === 'emoji') displayText = 'üòä';

      ctx.fillText(displayText, 64, 64);

      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.8, height * 0.7), mat);
      mesh.position.z = 0.01;
      group.add(mesh);

      keyMesh.userData.isKey = true;
      keyMesh.userData.key = char;
      group.userData.isKey = true;
      group.userData.key = char;

      return group;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, frame) {
      if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();

        if (!hitTestSourceRequested) {
          session.requestReferenceSpace("viewer").then((space) => {
            session.requestHitTestSource({ space }).then((source) => {
              hitTestSource = source;
            });
          });

          session.addEventListener("end", () => {
            hitTestSourceRequested = false;
            hitTestSource = null;
          });

          hitTestSourceRequested = true;
        }

        if (hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(referenceSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }

      if (activePanel && reticle.visible) {
        activePanel.position.setFromMatrixPosition(reticle.matrix);
        activePanel.quaternion.setFromRotationMatrix(reticle.matrix);
      }

      if (textDisplayPanel) {
        updateTextDisplay();
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>